# 13 阻塞队列
## 13.1 阻塞队列的由来
生产者-消费者模式: 生产者->缓冲池->消费者
实现难点: BlockingQueue Java实现类
- 线程安全问题: 重复消费+死锁
- 等待-唤醒逻辑: 缓存池空了,要阻塞消费者,唤醒生产者;缓存池满了,要阻塞生产者,唤醒消费者
## 13.2 BlockingQueue的操作方法
四组方法用于插入~移除~检查元素:

| 方法\处理方式 | 抛出异常    | 返回特殊值 | 阻塞   | 超时退出        |
|---------|---------|-------|------|-------------|
| 插入      | add     | offer | put  | offer(time) |
| 移除      | remove  | poll  | take | poll(time)  |
| 检查      | element | peek  | -    | -           |
- 抛出异常: 操作不成功就抛出异常, 如 IllegalStateException
- 返回特殊值: 操作不成功返回特殊值,如 true/false
- 阻塞: 操作不成功就阻塞
- 超时退出: 操作不成功就阻塞到超时
注意点:
- 不能插入null
- remove(o)效率低,慎用

## 13.3 BlockingQueue的实现类
### 13.3.1 ArrayBlockingQueue
ArrayBlockingQueue: 
- capacity: 队列大小,初始化后不可改变
- fair: 是否公平锁
### 13.3.2 LinkedBlockingQueue
LinkedBlockingQueue: 默认大小是Integer.MAX_VALUE,先进先出排序
### 13.3.3 DelayQueue
DelayQueue: 延迟队列,到期才可以取值,没有大小限制
### 13.3.4 PriorityBlockingQueue
PriorityBlockingQueue: 优先级由传入的Compator对象决定
### 13.3.5 SynchronousQueue
SynchronousQueue: 无缓冲,没有容量限制,只存一个元素,每次只能有一个线程进行读或写,读和写操作必须交替进行
## 13.4 阻塞队列的原理
## 13.5 示例和使用场景