# 11 AQS
:wusd
AQS: AbstractQueuedSynchronizer抽象队列同步器
- 三特性:
    + 抽象: 模板方法,实现主要逻辑,部分方法由子类实现
    + 队列: FIFO存储Node
    + 同步器: 实现同步功能
- 用途及实现: 用于构建锁和同步器的框架,比如: ReentrantLock/Semaphore/ReentrantReadWriteLock/SynchronousQueue/FutureTask
- 子类可覆盖方法: getState()~setState()~compareAndSetState()
- 数据结构: Node实现队列,Node拥有线程
- 同步方式:
  1. 独占模式(Exclusive)
  2. 共享模式(Share)
- 获取资源: 自旋CAS锁
- 释放资源: 
## 11.1 AQS简介
AQS: AbstractQueuedSynchronizer
- 抽象: 抽象类,实现主要逻辑,部分方法由子类实现(模板方法模式)
- 队列: FIFO存储数据
- 同步: 实现同步功能

ReentrantLock,Semaphore,ReentrantReadWriteLock,SynchronousQueue,FutureTask都是基于AQS.


## 11.2 AQS的数据结构
子类覆盖AQS的getState()~setState()~compareAndSetState()来实现自己的逻辑.
数据结构是: 队列结构,存储拥有线程的Node节点

## 11.3 资源共享模式
资源共享模式:
- 独占模式(Exclusive): ReentrantLock
- 共享模式(Share): 同时被多个线程获取,如Semaphore/CountDownLatch

```java
static final class Node {
    // 共享节点
    static final Node SHARED = new Node();
    // 独占节点
    static final Node EXCLUSIVE = null;
    
    // waitStatus: 取消
    static final int CANCELLED =  1;
    // waitStatus: 需要被唤醒
    static final int SIGNAL = -1;
    // waitStatus: 等待条件
    static final int CONDITION = -2;
    // waitStatus: 有资源可用
    static final int PROPAGATE = -3;
    
    // 等待状态
    volatile int waitStatus;
    // 上个节点
    volatile Node prev;
    // 下个节点
    volatile Node next;
    // 节点对应的线程
    volatile Thread thread;
    // 等待队列的下个节点
    Node nextWaiter;
    
    // 判断共享模式的方法
    final boolean isShared() {
        return nextWaiter == SHARED;
    }
    Node(Thread thread, Node mode) {
        this.nextWaiter = mode;
        this.thread = thread;
    }
}

class AQS {
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
    }
}
```

## 11.4 AQS的主要方法源码解析
AQS子类必须实现的方法:
- isHeldExclusively(): 该线程是否独占资源
- tryAcquire(int): 独占尝试获取资源,成功返回true,失败返回false
- tryRelease(int): 独占尝试释放资源,成功返回true,失败返回false
- tryAcquireShared(int): 共享尝试获取资源,-1表示失败,0表示成功,正数表示还有剩余资源
- tryReleaseShared(int): 共享尝试释放资源,成功返回true,失败返回false

### 11.4.1 获取资源

```java
import org.w3c.dom.Node;

public class AQS {
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
    private Node enq(final Node node) {
        while (true) {
            Node t = tail;
            if (t== null) {
                if (compareAndSetHead(new Node))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
}
```

### 11.4.2 释放资源

```java
import java.util.concurrent.locks.LockSupport;

public class AQS {
    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

    private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        if (ws < 0)
            compareAndSetWaitStatus(node, ws, 0);
        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
}
```