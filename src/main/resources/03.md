# 3 线程组和线程优先级
## 3.1 线程组(ThreadGroup)
ThreadGroup:
- 树状结构,里面下级线程可以使用上级线程,上级线程不能使用下级线程,防止线程无法被GC
- 所有线程必有线程组, main创建的线程默认为main
java->c03.ThreadGroupTest
## 3.2 线程的优先级
线程优先级:
- 1-10,实际只有低中高
- 不是绝对有效,只是建议
java->c03.ThreadPriorityTest

## 3.3 线程组的常用方法和数据结构
### 3.3.1 线程组的常用方法
线程组常用方法:
java->c03.ThreadGroupMethodTest
```java
public class Demo {
}
```

### 3.3.2 线程组的数据结构
线程组:
- parent父线程组
- Thread[]: 线程列表
```java
public class ThreadGroup implements Thread.UncaughtExceptionHandler {
    // 父线程组
    private final ThreadGroup parent;
    // 线程组名称
    String name;
    // 线程最大优先级
    int maxPriority;
    // 是否被销毁
    boolean destroyed;
    // 是否守护线程
    boolean daemon;
    // 是否允许中断
    boolean vmAllowSuspension;
    
    // 未启动的线程数
    int nUnstartedThreads = 0;
    // 线程数
    int nthreads;
    // 线程数组
    Thread threads[];
    
    // 子线程组数量
    int ngroups;
    // 子线程组数组
    ThreadGroup groups[];
    
    private ThreadGroup() {
        this.name = "system";
        this.maxPriority = Thread.MAX_PRIORITY;
        this.parent = null;
    }
    
    // 默认父线程组是创建的线程的线程组
    public ThreadGroup(String name) {
        this(Thread.currentThread().getThreadGroup(), name);
    }
    
    public ThreadGroup(ThreadGroup parent, String name) {
        this(checkParentAccess(parent), parent, name);
    }
    
    private ThreadGroup(Void unused, ThreadGroup parent, String name) {
        this.name = name;
        this.maxPriority = parent.maxPriority;
        this.daemon = parent.daemon;
        this.vmAllowSuspension = parent.vmAllowSuspension;
        this.parent = parent;
        parent.add(this);
    }
    
    private static Void checkParentAccess(ThreadGroup parent) {
        parent.checkAccess();
        return null;
    }
    // 判断当前线程是否有修改线程组的权限
    public final void checkAccess() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkAccess(this);
        }
    }
}
```