# 9 synchronized与锁
多线程的锁都是对象锁,类锁锁的是Class对象(多个实例共享)

:wusd
Java的锁都是对象锁,类锁和synchronized static锁的是对象(所有实例共享)

## 9.1 synchronized关键锁
synchronized的三种方式:
```java
public class Demo {
    // 锁是当前实例
    public synchronized void instanceLock(){
    }
    // 锁是class对象
    public static synchronized void classLock() {
    }
    //锁是括号的对象
    public void blockLock() {
        Object o = new Object();
        synchronized (o) {}
    }
    // 两者等价
    public synchronized void instanceLock() {
    }
    public void blockLock() {
        synchronized (this) {}
    }
    
    // 两者等价2
    public static synchronized void classLock() {}
    public static void blockLock() {
        synchronized (this.getClass()) {}
    }
}
```
## 9.2 几种锁
对象的锁状态: 由低到高,锁容易升级,降级比较苛刻
- 无锁
- 偏向锁
- 轻量级锁
- 重量级锁

:wusd
几种锁: 由低到高,锁容易升级,不容易降级
1. 无锁
2. 偏向锁
3. 轻量级锁
4. 重量级锁

### 9.2.1 Java对象头
对象头:

| 长度     | 内容                     | 说明           |
|--------|------------------------|--------------|
| 32/64b | Mark Word              | hashcode或锁信息 |
| 32/64b | Class Metadata Address | 对象类型数据的指针    |
| 32/64b | Array length           | 数组的长度(如果是数组) |
- 每个Java对象都有对象头
- 非数组,2个字宽存储对象头;数组,3个字段存储对象头
- 32位处理器,一个字宽32位;64位处理器,一个字宽64位

Mark Word的格式

| 锁状态  | 29bit或61bit    | 1bit是否偏向锁 | 2bit 锁标志位 |
|------|----------------|-----------|-----------|
| 无锁   |                | 0         | 01        |
| 偏向锁  | 线程ID           | 1         | 01        |
| 轻量级锁 | 指向栈中锁记录的指针     | 这一位不用于偏向锁 | 00        |
| 重量级锁 | 指向互斥量(重量级锁)的指针 | 这一位不用于偏向锁 | 10        |
| GC标记 |                | 这一位不用于偏向锁 | 11        |

:wusd
Java对象头: 数组3字宽,对象2字宽(1字宽=32bit/64bit)
- Mark Word: hashCode/锁信息
  + 无锁: 前29bit/61bit:空,偏向锁位:0,锁标志位:01
  + 偏向锁: 前29bit/61bit:线程ID,偏向锁位:1,锁标志位:01
  + 轻量级锁: 前29bit/61bit:栈中锁记录的指针,偏向锁位:无,锁标志位:00
  + 重量级锁: 前29bit/61bit:互斥量(重量级锁)的指针,偏向锁位:无,锁标志位:10
  + GC标记: 前29bit/61bit:空,偏向锁位:无,锁标志位:11
- Class Metadata Address: 指向Class的指针
- Array Length: 数组长度(数组才有!!!)

### 9.2.2 偏向锁
对锁设置变量,如果发现变量是true,表示没有资源竞争,就不走加锁/解锁流程.
            如果是false,则进入加锁流程

:wusd
偏向锁:
- 产生原因: 大多数锁总是同一线程获得
- 概述: 对锁设置变量,如果发现变量是true,那么没有资源竞争,没有加锁/解锁流程.如果是false,则开始锁竞争.
- 实现原理
CAS: Compare and Swap,比较并设置,CPU级别的原子操作
#### 实现原理
1. 线程A首次进入同步块
   - 对象处于可偏向状态
   - CAS成功: 将线程A的ID写入对象头
   - 对象进入偏向锁状态,偏向线程A
2. 线程A再次进入同步块
   - 检查对象头中的ThreadID == 线程A的ID
   - 直接进入同步块,无同步开销
3. 线程B尝试进入同步块
   - 检查对象头中的ThreadID != 线程B的ID
   - 立即触发偏向锁撤销(不尝试CAS替换ThreadID)
   - 在安全点暂停线程A
   - 撤销偏向锁,升级为轻量级锁
   - 恢复线程,线程B通过CAS竞争轻量级锁

#### 撤销偏向锁
设置不使用偏向锁: java -XX:UseBiasedLocking=false
撤销偏向锁:
1. 线程B尝试获取偏向锁,发现对象偏向线程A
2. JVM在安全点暂停所有线程
3. 检查线程A状态:
   - 如果线程A不活跃或已退出同步块: 将对象恢复为无锁状态
   - 如果线程A仍在同步块内(常见情况):
     1. 遍历线程A栈,找到对应Lock Record
     2. 将原Mark Word复制到Lock Record的displaced header
     3. 将对象头Mark Word指向Lock Record, 标志位设为00 (轻量级锁)
4. 恢复所有线程
5. 线程B开始以轻量级锁的方式竞争锁

### 9.2.3 轻量级锁
轻量级锁:
轻量级锁的加锁: 一个线程进入同步块,对象无锁且不可偏向 或 刚撤销偏向锁时, 会触发
1. 创建锁记录(Lock Record)
   - 当前线程的栈中创建Lock Record
   - Lock Record: 
     + Displaced Mark Word: 原始Mark Word
     + Object Reference: 当前被锁对象的引用
2. CAS竞争锁: CAS把对象头的Mark Word替换为当前线程Lock Record的指针
3. 处理CAS结果:
   - CAS成功:
     + 对象头锁标记位为00
     + 线程进入同步块
   - CAS失败:(Mark Word指向其他线程的Lock Record)
     + 自旋优化: 在空循环中不断重试CAS, CAS有限制次数或时间
     + 锁升级: 自旋失败达到次数限制或时间限制, 升级为重量级锁
       1. 线程获得Monitor
       2. 对象头的Mark Word指向这个Monitor
       3. 所有线程都被堵塞,进入Monitor的等待队列
       4. 锁标识为10
轻量级锁的释放:
### 9.2.4 重量级锁
### 9.2.5 总结锁的升级流程
### 9.2.6 各种锁的优缺点对比