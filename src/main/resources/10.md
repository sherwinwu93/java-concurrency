# 10 CAS与原子操作
## 10.1 乐观锁和悲观锁的概念
- 悲观锁: 每次访问共享资源时都加锁,确保同步块只有一个线程执行.
    应用于读少写多
- 乐观锁: 访问共享资源不加锁,利用CAS确保线程安全.
    应用于读多写少

:wusd
乐观锁与悲观锁:
- 悲观锁: 
  + 默认访问共享资源时会冲突,每次都加锁,只允许一个线程操作
  + 适用: 读少写多
- 乐观锁:
  + 默认访问共享资源不冲突,每次都不加锁,利用CAS的原子性保证线程安全
  + 无死锁,因为不加锁
  + 适用: 读多写少
## 10.2 CAS的概念
- CAS: Compare And Swap
  + 三个值: 如果V==E,则设置V=N; 否则说明有其他线程改过数据,啥都不做
    - V: 变量(variable)
    - E: 期望值(expected)
    - N: 新值(new)
  + 原子性: 在CPU级别确保Compare And Swap原子性,不会出现比较时正常,修改时数据已经被其他线程修改的情况

:wusd
CAS:
- CAS: 比较并交换(Compare And Swap)
  + 原理: 三个值V变量,E期望值,N新值; 如果V==E,则设置V=N; 否则失败(因为有其他线程改过数据)
  + 原子性: CPU级别确保CAS的原子性,不会出现比较后被其他线程修改数据的情况
  + 多线程同时CAS时,只有一个成功,其他被告知失败
## 10.3 Java实现CAS的原理-Unsafe类
Unsafe: Java底层类,提供CAS操作,native方法

:wusd
Unsafe: Java CAS实现类,由native实现

## 10.4 原子操作-AtomicInteger类源码间析
原子类:
- 原子更新基本类型
- 原子更新数组
- 原子更新引用
- 原子更新字段(属性)

- 里面用Unsafe来实现

:wusd
原子类:
- 原子类用途:
  + 原子更新基本类型
  + 原子更新数组
  + 原子更新引用
  + 原子更新字段(属性)
- 实现: 使用Unsafe实现

## 10.5 CAS实现原子操作的三大问题

:wusd
CAS实现原子类的三大问题:
1. ABA问题: 
   - V的值最初的值是A,中途变为B,又变回A,CAS无法识别.
   - 解决: 增加版本号或时间戳
2. 循环时间长开销大
   - 循环CAS直到成功为止,如果循环时间长会大量占用资源.
   - 解决: CAS失败后,睡眠一小段时间再自旋
3. 只能保证一个共享变量的原子操作
   - 解决: 使用AtomicReference,多个变量放到同一个对象CAS操作; 使用锁

### 10.5.1 ABA问题
ABA问题: 原来是A,变成了B,又变回了A. 变量增加版本号或时间戳

### 10.5.2 循环时间长开销大
- CAS自旋锁: 循环CAS,直到成功为止.
    CAS失败,自旋会占用大量资源. CAS失败后,睡眠一小段时间再自旋

### 10.5.3 只能保证一个共享变量的原子操作
两者解决方案:
1. AtomicReference: 把多个变量放到同一个对象CAS操作
2. 使用锁: 同步区的代码只有一个线程可以操作

