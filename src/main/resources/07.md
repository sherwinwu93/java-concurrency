# 7 重排序和happens-before
## 7.1 什么是重排序
重排序: 不影响结果的情况下,把指令的执行顺序改变
- 编译器优化重排: 不影响串行顺序,改变指令执行的顺序
- 指令并行重排: 下一个指令,对上个指令没有数据依赖时,改变指令执行的顺序
- 内存系统重排: 加载和存储顺序改变
## 7.2 顺序一致性模型与JMM的保证
内存模型参考顺序一致性设计

### 7.2.1 数据竞争与顺序一致性
数据竞争: 线程A写变量,线程B读变量,读写没有同步,导致不确定性
顺序一致性: JMM保证如果程序是正确同步的,那么执行的结果是确定的
    用好volatile~final~synchronized

### 7.2.2 顺序一致性模型
顺序一致性模型:
- 线程中所有操作都按Java代码执行
- 线程中每个操作都是原子的,且对所有线程可见
- eg:
  - 线程A和B同步: A1->A2->A3->B1->B2->B3
  - 线程A和B无同步: A1->B1->A2->B2->A3->B3 局部有序

### 7.2.3 JMM中同步程序的顺序一致性效果
JMM在同步代码块里面会重排,保证了执行结果不变

### 7.2.4 JMM中未同步程序的顺序一致性效果
未同步程序:
- 最小安全性: 线程读取的值,要么是之前其他线程写入的,要么是初始值,不会凭空产生
未同步程序:
- JMM单线程会重排,保证结果一致
- JMM不保证所有操作立即可见
- JMM不保证对64long和double的写操作原子性

## 7.3 happens-before
### 7.3.1 什么是happens-before
happens-before:
1. 如果操作A happens-before 操作B, 那么操作A结果对于操作B可见
2. 如果操作A happens-before 操作B, 但是不影响结果,允许重排

### 7.3.2 天然的happens-before关系
happens-before规则:
- 程序顺序规则: 一个线程中的每个操作happens-before线程中所有后续操作
- 监视器锁规则: 锁的解锁 happnes-before 随后的加锁(同一把锁)
- volatile规则: volatile变量的写操作 happnes-before 后续的读操作
- 传递性: A happens-before B, B happens-before C, 那么A happens-before C
- start规则: 线程A启动线程B,那么线程A这个操作 先于 线程B的所有操作
- join规则: 线程A调用线程B的join(), 线程B的任意操作 happens-before 线程A的join()
```java
// eg:happens-before和重排
public class HappensBefore { 
    public static void main(String[] args) {
        int a = 1; // A操作
        int b = 2;// B操作
        int sum = a + b;// C操作
        System.out.println(sum);
//        操作A~B可能重排序,但是操作C不会重排序
        f1();
        f2();
// 变量声明: 可能重排
//        f1和f2严格顺序执行,因为方法调用不会重排序
    }
}
```

