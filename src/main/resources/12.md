# 12 线程池原理
## 12.1 为什么要使用线程池
为什么要使用线程池?
1. 创建/销毁线程消耗大,线程池复用已创建的线程
2. 控制并发数量,并发数量过大,可能造成服务器崩溃(主要原因)
3. 对线程统一管理

## 12.2 线程池的原理
线程池接口及实现类: Executor + ThreadPoolExecutor

### 12.2.1 ThreadPoolExecutor提供的构造方法
ThreadPoolExecutor构造方法参数:
- int corePoolSize, //核心线程数
- int maximumPoolSize, //最大线程数
- long keepAliveTime, //非核心线程闲置时间
- TimeUnit unit,// 时间单位
- BlockingQueue<Runnable> workQueue, //阻塞队列,等待执行的Runnable任务
  1. LinkedBlockingQueue: 链表阻塞队列
  2. ArrayBlockingQueue: 数组阻塞队列
  3. SynchronousQueue: 同步队列,所有队列都是同步的
  4. DelayQueue: 延迟队列
- ThreadFactory threadFactory, // 线程工厂
- RejectedExecutionHandler handler: 拒绝处理策略,线程数量大于最大线程数时
  1. ThreadPoolExecutor.AbortPolicy: 默认,丢弃异常并抛出异常
  2. ThreadPoolExecutor.DiscardPolicy: 丢弃不抛出异常
  3. ThreadPoolExecutor.DiscardOldestPolicy: 丢弃最老的,即队列最前面的任务,重新执行程序
  4. ThreadPoolExecutor.CallerRunsPolicy: 由调用线程处理该任务
核心线程 vs 非核心线程: 核心线程永远不销毁,非核心线程空闲超过keepAliveTime,则销毁

### 12.2.2 ThreadPoolExecutor的策略
线程池本身有调度线程: 创建线程~销毁线程~任务队列管理~线程队列管理等
volatile int runState:
- RUNNING: 线程池创建后
- SHUTDOWN: 调用shutdown()后,不能接受新任务,清除空闲worker,等待阻塞队列调用完成
- STOP: 调用shutdownNow(),停止接受新任务,清除所有worker,阻塞队列全部丢弃
- TIDYING: 所有任务终止时,线程池进入TIDYING状态,等待terminated()方法调用
- TERMINATED: terminated()调用后

### 12.2.3 线程池主要的任务处理流程
![./thread-pool-progress.png]
核心: execute方法 java-c12.ThreadPoolExecutor.java
```java
public class ThreadPoolExecutor { 
    public void execute(Runnable command) { 
        if (command == null) throw new NullPointerException();
        int c = ctl.get();
        // 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 2.如果不小于corePoolSize,则将任务加入阻塞队列
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            // 2.1 如果isRunning返回false(说明线程池关闭中),则remove任务,执行拒绝策略
            if (!isRunning(recheck) && remove(command))
                reject(command);
            // 2.2 线程池running状态,但是没有线程,则创建线程
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        // 3.如果放入workQueue失败,则创建非核心线程执行任务
        // 如果创建非核心线程失败,执行拒绝策略
        else if (!addWorker(command, false))
            reject(command);
    }
}
```

### 12.2.4 ThreadPoolExecutor如何做到线程复用的?
```java
public class ThreadPoolExecutor {
  /**
   * @param firstTask 任务
   * @param core 是否核心线程
   * @return
   */
  // addWorker上半部分: 创建核心线程时,判断是否核心线程数满了吗;创建非核心线程时,判断是否全部线程数满了吗?
    private boolean addWorker(Runnable firstTask, boolean core) {
        // 重试标签
        retry:
        for (;;) {
            // 线程池上下文
            int c = ctl.get();
            // 获取线程池runState
            int rs = runStateOf(c);
            
          // 当必要时才检查queue是否为空
          // queue是空时,不增加worker
          if (rs >= SHUTDOWN &&
                    !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
                return false;
            
            for (;;) {
                // 获取worker数
                int wc = workerCountOf(c);
                if (wc >= CAPACITY ||
                        // 1. 如果core是true,判断当前线程数是否小于核心线程数
                        // 2. 如果core是false,判断当前线程数是否小于最大线程数
                        wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                
                if (compareAndIncrementWorkerCount(c)) //比较且增加工作线程
                    break retry;
                c = ctl.get();
                if (runStateOf(c) != rs) // runState改变则重试
                    continue retry;
            }
        }
    }
}
```

```java
import java.util.concurrent.locks.ReentrantLock;

public class ThreadPoolExecutor {
  // addWorker下半部分,
  private void addWorker(Runnable firstTask, boolean core) {
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
      // 1.创建worker对象
      w = new Worker(firstTask);
      // 2. 实例化Thread对象
      final Thread t = w.thread;
      if (t != null) {
          // 3.锁线程池
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            int rs = runStateOf(ctl.get());
            
            // rs未关闭, 或者 rs关闭且task为null 
            if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                if (t.isAlive()) //t是否可以启动
                    throw new IllegalThreadStateException();
                workers.add(w);
                int s = workers.size();
                if (s > largestPoolSize)
                    largestPoolSize = s;
                workerAdded = true;
            }
        } finally {
            mainLock.unlock();
        }
        if (workerAdded) {
            // 启动线程
            t.start();
            workerStarted = true;
        }
      }
    } finally {
        if (! workerStarted) 
            addWorkerFailed(w);
    }
    return workerStarted;
  }
}
```

```java
import com.sun.corba.se.spi.orbutil.threadpool.Work;

private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
  final Thread thread;
  Runnable firstTask;

  Worker(Runnable firstTask) {
      setState(-1);
      this.firstTask = firstTask;
      this.thread = getThreadFactory().newThread(this);
  }
  
  public void run() {
      runWorker(this);
  }
}
```
```java
public class ThreadPoolExecutor {
    final void runWorker(Worker w) { 
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock();
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
            }
        } finally {
            afterExecute(task, thrown);
        }
    }
}
```
## 12.3 四种常见的线程池
### 12.3.1 newCachedThreadPool
适用场景: 很多短时间任务,线程复用率高.
CacheThreadPool运行流程:
1. 提交任务到线程池
2. 因为corePoolSize为0,不创建核心线程,线程池最大为Integer.MAX_VALUE
3. 尝试把任务添加到SynchronousQueue
4. 如果入列成功,等待空闲线程执行.如果没有空闲线程,则创建非核心线程,从队列拉取任务并执行.
5. 如果SynchronousQueue有任务在等待,则会阻塞.
------
CacheThreadPool:
- 只创建非核心线程
- 线程空闲超过60s,则回收
- 不会触发拒绝策略,因为线程池很大
```java
public class Demo {
  public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
            new SynchronousQueue<>());
  }
}
```
### 12.3.2 newFixedThreadPool

newFixedThreadPool vs CacheThreadPool:
- 只创建核心线程
- 如果队列里没有任务,线程会阻塞,不会被回收.(因此占用资源更多)
- 不会触发拒绝策略,因为队列很大
```java
public class Demo {
  public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque<>());
  }
}
```
### 12.3.3 newSingleThreadExecutor
和FixedThreadPool一样,但是只有一个核心线程,因此会严格按顺序执行.
```java
public class Demo {
  public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
    return new FinializableScheduledThreadPoolExecutor(
            new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>()));
  }
}
```
### 12.3.4 newScheduledThreadPool
// 定长线程池,定期周期任务执行
```java
public class Demo {
  public static ExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
  }
  
  public ScheduledThreadPoolExecutor(int corePoolSize) {
      super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPLIVE_MILLIS, MILLISECONDS,
              new DelayedWorkQueue());
  }
}
```