# 5 Java线程间的通信
线程有自己的私有上下文,一般互不干涉,但是需要相互协作时,就需要进行通信.

## 5.1 锁与同步
锁:对象,一次只能被一个线程持有.但是一个线程可以同时持有多个锁.
同步: 多个线程按顺序执行

java->c05.NoneLock
java->c05.ObjectLock

## 5.2 等待/通知机制
- 问题: 获取锁耗费资源: 线程A拿到锁,线程B进入BLOCKED状态. 线程B会不停地获取锁,直到线程A释放锁.
- 等待同步机制解决BLOCKED耗费资源问题
java->c05.WaitAndNotify

## 5.3 信号量 volatile
volatile: volatile声明的变量,在线程A修改后,线程B~C~D...马上拿到最新的值
java->c05.Signal

超过2个线程相互合作时,用锁和等待通知机制就不够了,用信号量解决.
信号量就是大家都共有的变量,根据这个变量改变自己的状态

## 5.4 管道
基于字符的管道流: PipedReader,PipedWriter
基于字节的管道流: PipedInputStream,PipedOutputStream
应用场景: 一个线程需要另外一个线程发送信息或文件时
java->c05.Pipe

## 5.5 其他通信相关
### 5.5.1 join方法
让当前线程进入等待,等join的线程执行完成,再继续当前线程.
java->c05.Join
### 5.5.2 sleep方法
sleep不会释放锁,wait会释放锁
sleep vs wait:
- sleep必须有时间,wait可以没有
- sleep只释放CPU,不释放锁,wait都释放
- sleep可以任意位置,wait必须在同步块中
### 5.5.3 ThreadLocal类
ThreadLocal: 为每个线程创建一个变量副本,只能由自己线程访问
java->c05.ThreadLocalDemo

场景: 这些涉及多个对象的初始化和关闭,ThreadLocal
1. 数据库连接
2. Session管理

### 5.5.4 InheritableThreadLocal
不单单自己可以用这个变量副本,子线程也可以使用